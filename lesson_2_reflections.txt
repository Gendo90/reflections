What happens when you initialize a repository? Why do you need to do it?

You can initialize a repository using 'git init' in the directory where you
want to create the repository. This creates a hidden .git file that is used
to keep track of the repository (records changes, commits, etc.), and you
need to initialize this repository in order to make and share your files
with others, and also to implement Git as version control for your software.
The repository starts out with 0 commits, and you can run 'git status' to see
how there have been no commits made yet, and to see what files are 'untracked'
in your repository.

How is the staging area different from the working directory and the
repository? What value do you think it offers?

The staging area temporarily stores files that will be included in a commit,
while the working directory shows where the files are located and usually
does not change. Similarly, these commits using the files in the staging area
are what actually change the information and files in the repository, so
it seems like a good idea to have a step where you can review all files to
be changed and double-check that you really want to make these changes!
Otherwise, it would be easy to just randomly commit files if you typed in
a command wrong, there would be too many commits that have not been thought
through because there is no checking or review step (which would use the
staging area).

How can you use the staging area to make sure you have one commit per logical
change?

You can compare the files in the staging area to the files in the working
directory and also to the files in the repository to make sure that you are
adding the files with the correct changes you want made. This reduces the
chance of accidental commits that could have errors or unwanted changes in
them. It also makes it more difficult to change the repository, since you
need to complete more than a simple "save" to update the repository, which
helps maintain the security and integrity of the repository.

What are some situations when branches would be helpful in keeping your
history organized? How would branches help?

Branches are useful if the code has new features that can be added later to
upgrade code, or for something like optimization. You can put this additional
code on different branches and work on it without it affecting the main
code branch, and keep rolling back changes as necessary if the newer code
does not work. You can run these changes parallel to the main branch,
especially if the main branch of the program needs to remain stable because
it is used to continuously run a program, website, operating system,
hardware device, etc. especially if there could be huge problems if the
software does not run consistently, even if it is not optimized or fully-
featured.
